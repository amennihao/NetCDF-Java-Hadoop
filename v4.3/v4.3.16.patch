diff --git a/cdm/pom.xml b/cdm/pom.xml
index be0687d..f339650 100644
--- a/cdm/pom.xml
+++ b/cdm/pom.xml
@@ -105,7 +105,11 @@
       <artifactId>slf4j-jdk14</artifactId>
       <scope>test</scope>
     </dependency>
-
+    <dependency>
+        <groupId>org.apache.hadoop</groupId>
+        <artifactId>hadoop-core</artifactId>
+        <version>1.0.4</version>
+    </dependency>
   </dependencies>
 
 
diff --git a/cdm/src/main/java/ucar/ma2/Array.java b/cdm/src/main/java/ucar/ma2/Array.java
index f11076d..4d77fcc 100644
--- a/cdm/src/main/java/ucar/ma2/Array.java
+++ b/cdm/src/main/java/ucar/ma2/Array.java
@@ -34,6 +34,7 @@ package ucar.ma2;
 
 import java.util.List;
 import java.util.ArrayList;
+import java.io.Serializable;
 import java.nio.*;
 
 /**
@@ -72,7 +73,7 @@ import java.nio.*;
  * @see Index
  * @see IndexIterator
  */
-public abstract class Array {
+public abstract class Array implements Serializable{
 
 /* implementation notes.
   Could create interface for Ranges, ScatterIndex and pass array of that (?)
diff --git a/cdm/src/main/java/ucar/ma2/ArrayBoolean.java b/cdm/src/main/java/ucar/ma2/ArrayBoolean.java
index 4b0442f..b8fc17a 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayBoolean.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayBoolean.java
@@ -32,6 +32,8 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Concrete implementation of Array specialized for booleans.
  * Data storage is with 1D java array of booleans.
@@ -41,7 +43,7 @@ package ucar.ma2;
  * @see Array
  * @author caron
  */
-public class ArrayBoolean extends Array {
+public class ArrayBoolean extends Array implements Serializable{
 
   // package private. use Array.factory() */
   static ArrayBoolean factory(Index index) {
@@ -202,7 +204,7 @@ public class ArrayBoolean extends Array {
   public void setObject(int index, Object value) { storage[index] = (Boolean) value; }
 
     /** Concrete implementation of Array specialized for byte, rank 0. */
-  public static class D0 extends ArrayBoolean {
+  public static class D0 extends ArrayBoolean implements Serializable{
     private Index0D ix;
     /** Constructor. */
     public D0 () {
@@ -224,7 +226,7 @@ public class ArrayBoolean extends Array {
   }
 
   /** Concrete implementation of Array specialized for boolean, rank 1. */
-  public static class D1 extends ArrayBoolean {
+  public static class D1 extends ArrayBoolean implements Serializable{
     private Index1D ix;
     /** Constructor for array of shape {len0}. */
     public D1 (int len0) {
@@ -246,7 +248,7 @@ public class ArrayBoolean extends Array {
   }
 
   /** Concrete implementation of Array specialized for boolean, rank 2. */
-  public static class D2 extends ArrayBoolean {
+  public static class D2 extends ArrayBoolean implements Serializable{
     private Index2D ix;
     /** Constructor for array of shape {len0,len1}. */
     public D2 (int len0, int len1) {
@@ -268,7 +270,7 @@ public class ArrayBoolean extends Array {
   }
 
   /** Concrete implementation of Array specialized for boolean, rank 3. */
-  public static class D3 extends ArrayBoolean {
+  public static class D3 extends ArrayBoolean implements Serializable{
     private Index3D ix;
     /** Constructor for array of shape {len0,len1,len2}. */
     public D3 (int len0, int len1, int len2) {
@@ -290,7 +292,7 @@ public class ArrayBoolean extends Array {
   }
 
   /** Concrete implementation of Array specialized for boolean, rank 4. */
-  public static class D4 extends ArrayBoolean {
+  public static class D4 extends ArrayBoolean implements Serializable{
     private Index4D ix;
     /** Constructor for array of shape {len0,len1,len2,len3}. */
     public D4 (int len0, int len1, int len2, int len3) {
@@ -312,7 +314,7 @@ public class ArrayBoolean extends Array {
   }
 
   /** Concrete implementation of Array specialized for boolean, rank 5. */
-  public static class D5 extends ArrayBoolean {
+  public static class D5 extends ArrayBoolean implements Serializable{
     private Index5D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4}. */
     public D5 (int len0, int len1, int len2, int len3, int len4) {
@@ -334,7 +336,7 @@ public class ArrayBoolean extends Array {
   }
 
   /** Concrete implementation of Array specialized for boolean, rank 6. */
-  public static class D6 extends ArrayBoolean {
+  public static class D6 extends ArrayBoolean implements Serializable{
     private Index6D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,}. */
     public D6 (int len0, int len1, int len2, int len3, int len4, int len5) {
@@ -356,7 +358,7 @@ public class ArrayBoolean extends Array {
   }
 
   /** Concrete implementation of Array specialized for boolean, rank 7. */
-  public static class D7 extends ArrayBoolean {
+  public static class D7 extends ArrayBoolean implements Serializable{
     private Index7D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,len6}. */
     public D7 (int len0, int len1, int len2, int len3, int len4, int len5, int len6) {
diff --git a/cdm/src/main/java/ucar/ma2/ArrayByte.java b/cdm/src/main/java/ucar/ma2/ArrayByte.java
index ae03972..1af2da6 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayByte.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayByte.java
@@ -32,6 +32,7 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
 import java.nio.ByteBuffer;
 
 /**
@@ -43,7 +44,7 @@ import java.nio.ByteBuffer;
  * @author caron
  * @see Array
  */
-public class ArrayByte extends Array {
+public class ArrayByte extends Array implements Serializable{
 
   // package private. use Array.factory() */
   static ArrayByte factory(Index index) {
@@ -333,7 +334,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 0.
    */
-  public static class D0 extends ArrayByte {
+  public static class D0 extends ArrayByte implements Serializable{
     private Index0D ix;
 
     public D0() {
@@ -358,7 +359,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 1.
    */
-  public static class D1 extends ArrayByte {
+  public static class D1 extends ArrayByte implements Serializable{
     private Index1D ix;
 
     public D1(int len0) {
@@ -383,7 +384,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 2.
    */
-  public static class D2 extends ArrayByte {
+  public static class D2 extends ArrayByte implements Serializable{
     private Index2D ix;
 
     public D2(int len0, int len1) {
@@ -408,7 +409,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 3.
    */
-  public static class D3 extends ArrayByte {
+  public static class D3 extends ArrayByte implements Serializable{
     private Index3D ix;
 
     public D3(int len0, int len1, int len2) {
@@ -433,7 +434,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 4.
    */
-  public static class D4 extends ArrayByte {
+  public static class D4 extends ArrayByte implements Serializable{
     private Index4D ix;
 
     public D4(int len0, int len1, int len2, int len3) {
@@ -458,7 +459,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 5.
    */
-  public static class D5 extends ArrayByte {
+  public static class D5 extends ArrayByte implements Serializable{
     private Index5D ix;
 
     public D5(int len0, int len1, int len2, int len3, int len4) {
@@ -483,7 +484,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 6.
    */
-  public static class D6 extends ArrayByte {
+  public static class D6 extends ArrayByte implements Serializable{
     private Index6D ix;
 
     public D6(int len0, int len1, int len2, int len3, int len4, int len5) {
@@ -508,7 +509,7 @@ public class ArrayByte extends Array {
   /**
    * Concrete implementation of Array specialized for byte, rank 7.
    */
-  public static class D7 extends ArrayByte {
+  public static class D7 extends ArrayByte implements Serializable{
     protected Index7D ix;
 
     public D7(int len0, int len1, int len2, int len3, int len4, int len5, int len6) {
diff --git a/cdm/src/main/java/ucar/ma2/ArrayChar.java b/cdm/src/main/java/ucar/ma2/ArrayChar.java
index 1706cc8..624059d 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayChar.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayChar.java
@@ -35,6 +35,7 @@ package ucar.ma2;
 import ucar.nc2.iosp.IospHelper;
 
 import java.util.List;
+import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 
@@ -47,7 +48,7 @@ import java.nio.CharBuffer;
  * @author caron
  * @see Array
  */
-public class ArrayChar extends Array {
+public class ArrayChar extends Array implements Serializable{
 
   /**
    * package private. use Array.factory()
@@ -513,7 +514,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 0.
    */
-  public static class D0 extends ArrayChar {
+  public static class D0 extends ArrayChar implements Serializable{
     private Index0D ix;
 
     /**
@@ -547,7 +548,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 1.
    */
-  public static class D1 extends ArrayChar {
+  public static class D1 extends ArrayChar implements Serializable{
     private Index1D ix;
 
     /**
@@ -581,7 +582,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 2.
    */
-  public static class D2 extends ArrayChar {
+  public static class D2 extends ArrayChar implements Serializable{
     private Index2D ix;
 
     /**
@@ -615,7 +616,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 3.
    */
-  public static class D3 extends ArrayChar {
+  public static class D3 extends ArrayChar implements Serializable{
     private Index3D ix;
 
     /**
@@ -649,7 +650,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 4.
    */
-  public static class D4 extends ArrayChar {
+  public static class D4 extends ArrayChar implements Serializable{
     private Index4D ix;
 
     /**
@@ -683,7 +684,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 5.
    */
-  public static class D5 extends ArrayChar {
+  public static class D5 extends ArrayChar implements Serializable{
     private Index5D ix;
 
     /**
@@ -717,7 +718,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 6.
    */
-  public static class D6 extends ArrayChar {
+  public static class D6 extends ArrayChar implements Serializable{
     private Index6D ix;
 
     /**
@@ -751,7 +752,7 @@ public class ArrayChar extends Array {
   /**
    * Concrete implementation of Array specialized for char, rank 7.
    */
-  public static class D7 extends ArrayChar {
+  public static class D7 extends ArrayChar implements Serializable{
     private Index7D ix;
 
     /**
diff --git a/cdm/src/main/java/ucar/ma2/ArrayDouble.java b/cdm/src/main/java/ucar/ma2/ArrayDouble.java
index 600170d..2c8afb5 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayDouble.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayDouble.java
@@ -32,6 +32,7 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 import java.nio.DoubleBuffer;
@@ -43,7 +44,7 @@ import java.nio.DoubleBuffer;
  * @see Array
  * @author caron
  */
-public class ArrayDouble extends Array {
+public class ArrayDouble extends Array implements Serializable{
 
   /** package private. use Array.factory() */
   static ArrayDouble factory(Index index) {
@@ -235,7 +236,7 @@ public class ArrayDouble extends Array {
   public void setObject(int index, Object value) { storageD[index] = ((Number)value).doubleValue(); }
 
   /** Concrete implementation of Array specialized for doubles, rank 0. */
-  public static class D0 extends ArrayDouble {
+  public static class D0 extends ArrayDouble implements Serializable{
     private Index0D ix;
     /** Constructor. */
     public D0 () {
@@ -257,7 +258,7 @@ public class ArrayDouble extends Array {
   }
 
   /** Concrete implementation of Array specialized for doubles, rank 1. */
-  public static class D1 extends ArrayDouble {
+  public static class D1 extends ArrayDouble implements Serializable{
     private Index1D ix;
     /** Constructor for array of shape {len0}. */
     public D1 (int len0) {
@@ -279,7 +280,7 @@ public class ArrayDouble extends Array {
   }
 
   /** Concrete implementation of Array specialized for doubles, rank 2. */
-  public static class D2 extends ArrayDouble {
+  public static class D2 extends ArrayDouble implements Serializable{
     private Index2D ix;
     /** Constructor for array of shape {len0,len1}. */
     public D2 (int len0, int len1) {
@@ -301,7 +302,7 @@ public class ArrayDouble extends Array {
   }
 
   /** Concrete implementation of Array specialized for doubles, rank 3. */
-  public static class D3 extends ArrayDouble {
+  public static class D3 extends ArrayDouble implements Serializable{
     private Index3D ix;
     /** Constructor for array of shape {len0,len1,len2}. */
     public D3 (int len0, int len1, int len2) {
@@ -332,7 +333,7 @@ public class ArrayDouble extends Array {
   }
 
   /** Concrete implementation of Array specialized for doubles, rank 4. */
-  public static class D4 extends ArrayDouble {
+  public static class D4 extends ArrayDouble implements Serializable{
     private Index4D ix;
     /** Constructor for array of shape {len0,len1,len2,len3}. */
     public D4 (int len0, int len1, int len2, int len3) {
@@ -354,7 +355,7 @@ public class ArrayDouble extends Array {
   }
 
   /** Concrete implementation of Array specialized for doubles, rank 5. */
-  public static class D5 extends ArrayDouble {
+  public static class D5 extends ArrayDouble implements Serializable{
     private Index5D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4}. */
     public D5 (int len0, int len1, int len2, int len3, int len4) {
@@ -376,7 +377,7 @@ public class ArrayDouble extends Array {
   }
 
   /** Concrete implementation of Array specialized for doubles, rank 6. */
-  public static class D6 extends ArrayDouble {
+  public static class D6 extends ArrayDouble implements Serializable{
     private Index6D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,}. */
     public D6 (int len0, int len1, int len2, int len3, int len4, int len5) {
@@ -398,7 +399,7 @@ public class ArrayDouble extends Array {
   }
 
   /** Concrete implementation of Array specialized for doubles, rank 7. */
-  public static class D7 extends ArrayDouble {
+  public static class D7 extends ArrayDouble implements Serializable{
     private Index7D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,len6}. */
     public D7 (int len0, int len1, int len2, int len3, int len4, int len5, int len6) {
diff --git a/cdm/src/main/java/ucar/ma2/ArrayFloat.java b/cdm/src/main/java/ucar/ma2/ArrayFloat.java
index 6fe191f..2e07889 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayFloat.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayFloat.java
@@ -32,6 +32,7 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.FloatBuffer;
 
@@ -44,7 +45,7 @@ import java.nio.FloatBuffer;
  * @see Array
  * @author caron
  */
-public class ArrayFloat extends Array {
+public class ArrayFloat extends Array implements Serializable{
   /** package private. use Array.factory() */
   static ArrayFloat factory(Index index) {
     return ArrayFloat.factory(index, null);
@@ -235,7 +236,7 @@ public class ArrayFloat extends Array {
   public void setObject(int index, Object value) { storage[index] = ((Number)value).floatValue(); }
 
   /** Concrete implementation of Array specialized for floats, rank 0. */
-  public static class D0 extends ArrayFloat {
+  public static class D0 extends ArrayFloat implements Serializable{
     private Index0D ix;
     /** Constructor. */
     public D0 () {
@@ -257,7 +258,7 @@ public class ArrayFloat extends Array {
   }
 
   /** Concrete implementation of Array specialized for floats, rank 1. */
-  public static class D1 extends ArrayFloat {
+  public static class D1 extends ArrayFloat implements Serializable{
     private Index1D ix;
     /** Constructor for array of shape {len0}. */
     public D1 (int len0) {
@@ -279,7 +280,7 @@ public class ArrayFloat extends Array {
   }
 
   /** Concrete implementation of Array specialized for floats, rank 2. */
-  public static class D2 extends ArrayFloat {
+  public static class D2 extends ArrayFloat implements Serializable{
     private Index2D ix;
     /** Constructor for array of shape {len0,len1}. */
     public D2 (int len0, int len1) {
@@ -301,7 +302,7 @@ public class ArrayFloat extends Array {
   }
 
   /** Concrete implementation of Array specialized for floats, rank 3. */
-  public static class D3 extends ArrayFloat {
+  public static class D3 extends ArrayFloat implements Serializable{
     private Index3D ix;
     /** Constructor for array of shape {len0,len1,len2}. */
     public D3 (int len0, int len1, int len2) {
@@ -323,7 +324,7 @@ public class ArrayFloat extends Array {
   }
 
   /** Concrete implementation of Array specialized for floats, rank 4. */
-  public static class D4 extends ArrayFloat {
+  public static class D4 extends ArrayFloat implements Serializable{
     private Index4D ix;
     /** Constructor for array of shape {len0,len1,len2,len3}. */
     public D4 (int len0, int len1, int len2, int len3) {
@@ -345,7 +346,7 @@ public class ArrayFloat extends Array {
   }
 
   /** Concrete implementation of Array specialized for floats, rank 5. */
-  public static class D5 extends ArrayFloat {
+  public static class D5 extends ArrayFloat implements Serializable{
     private Index5D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4}. */
     public D5 (int len0, int len1, int len2, int len3, int len4) {
@@ -367,7 +368,7 @@ public class ArrayFloat extends Array {
   }
 
   /** Concrete implementation of Array specialized for floats, rank 6. */
-  public static class D6 extends ArrayFloat {
+  public static class D6 extends ArrayFloat implements Serializable{
     private Index6D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,}. */
     public D6 (int len0, int len1, int len2, int len3, int len4, int len5) {
@@ -389,7 +390,7 @@ public class ArrayFloat extends Array {
   }
 
   /** Concrete implementation of Array specialized for floats, rank 7. */
-  public static class D7 extends ArrayFloat {
+  public static class D7 extends ArrayFloat implements Serializable{
     private Index7D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,len6}. */
     public D7 (int len0, int len1, int len2, int len3, int len4, int len5, int len6) {
diff --git a/cdm/src/main/java/ucar/ma2/ArrayInt.java b/cdm/src/main/java/ucar/ma2/ArrayInt.java
index 8455d36..e1effe7 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayInt.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayInt.java
@@ -32,6 +32,7 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 
@@ -44,7 +45,7 @@ import java.nio.IntBuffer;
  * @author caron
  * @see Array
  */
-public class ArrayInt extends Array {
+public class ArrayInt extends Array implements Serializable{
 
    // package private. use Array.factory()
   static ArrayInt factory(Index index) {
@@ -332,7 +333,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 0.
    */
-  public static class D0 extends ArrayInt {
+  public static class D0 extends ArrayInt implements Serializable{
     private Index0D ix;
 
     public D0() {
@@ -357,7 +358,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 1.
    */
-  public static class D1 extends ArrayInt {
+  public static class D1 extends ArrayInt implements Serializable{
     private Index1D ix;
 
     public D1(int len0) {
@@ -382,7 +383,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 2.
    */
-  public static class D2 extends ArrayInt {
+  public static class D2 extends ArrayInt implements Serializable{
     private Index2D ix;
 
     public D2(int len0, int len1) {
@@ -407,7 +408,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 3.
    */
-  public static class D3 extends ArrayInt {
+  public static class D3 extends ArrayInt implements Serializable{
     private Index3D ix;
 
     public D3(int len0, int len1, int len2) {
@@ -432,7 +433,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 4.
    */
-  public static class D4 extends ArrayInt {
+  public static class D4 extends ArrayInt implements Serializable{
     private Index4D ix;
 
     public D4(int len0, int len1, int len2, int len3) {
@@ -457,7 +458,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 5.
    */
-  public static class D5 extends ArrayInt {
+  public static class D5 extends ArrayInt implements Serializable{
     private Index5D ix;
 
     public D5(int len0, int len1, int len2, int len3, int len4) {
@@ -482,7 +483,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 6.
    */
-  public static class D6 extends ArrayInt {
+  public static class D6 extends ArrayInt implements Serializable{
     private Index6D ix;
 
     public D6(int len0, int len1, int len2, int len3, int len4, int len5) {
@@ -507,7 +508,7 @@ public class ArrayInt extends Array {
   /**
    * Concrete implementation of Array specialized for ints, rank 7.
    */
-  public static class D7 extends ArrayInt {
+  public static class D7 extends ArrayInt implements Serializable{
     private Index7D ix;
 
     public D7(int len0, int len1, int len2, int len3, int len4, int len5, int len6) {
diff --git a/cdm/src/main/java/ucar/ma2/ArrayLong.java b/cdm/src/main/java/ucar/ma2/ArrayLong.java
index 6b7c371..50ae4f8 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayLong.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayLong.java
@@ -32,6 +32,7 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
 import java.nio.ByteBuffer;
 import java.nio.LongBuffer;
 
@@ -44,7 +45,7 @@ import java.nio.LongBuffer;
  * @see Array
  * @author caron
  */
-public class ArrayLong extends Array {
+public class ArrayLong extends Array implements Serializable{
 
   /** package private. use Array.factory() */
   static ArrayLong factory(Index index) {
@@ -236,7 +237,7 @@ public class ArrayLong extends Array {
   public void setObject(int index, Object value) { storage[index] = ((Number)value).longValue(); }
 
   /** Concrete implementation of Array specialized for longs, rank 0. */
-  public static class D0 extends ArrayLong {
+  public static class D0 extends ArrayLong implements Serializable{
     private Index0D ix;
     /** Constructor. */
     public D0 () {
@@ -258,7 +259,7 @@ public class ArrayLong extends Array {
   }
 
   /** Concrete implementation of Array specialized for longs, rank 1. */
-  public static class D1 extends ArrayLong {
+  public static class D1 extends ArrayLong implements Serializable{
     private Index1D ix;
     /** Constructor for array of shape {len0}. */
     public D1 (int len0) {
@@ -280,7 +281,7 @@ public class ArrayLong extends Array {
   }
 
   /** Concrete implementation of Array specialized for longs, rank 2. */
-  public static class D2 extends ArrayLong {
+  public static class D2 extends ArrayLong implements Serializable{
     private Index2D ix;
     /** Constructor for array of shape {len0,len1}. */
     public D2 (int len0, int len1) {
@@ -302,7 +303,7 @@ public class ArrayLong extends Array {
   }
 
   /** Concrete implementation of Array specialized for longs, rank 3. */
-  public static class D3 extends ArrayLong {
+  public static class D3 extends ArrayLong implements Serializable{
     private Index3D ix;
     /** Constructor for array of shape {len0,len1,len2}. */
     public D3 (int len0, int len1, int len2) {
@@ -324,7 +325,7 @@ public class ArrayLong extends Array {
   }
 
   /** Concrete implementation of Array specialized for longs, rank 4. */
-  public static class D4 extends ArrayLong {
+  public static class D4 extends ArrayLong implements Serializable{
     private Index4D ix;
     /** Constructor for array of shape {len0,len1,len2,len3}. */
     public D4 (int len0, int len1, int len2, int len3) {
@@ -346,7 +347,7 @@ public class ArrayLong extends Array {
   }
 
   /** Concrete implementation of Array specialized for longs, rank 5. */
-  public static class D5 extends ArrayLong {
+  public static class D5 extends ArrayLong implements Serializable{
     private Index5D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4}. */
     public D5 (int len0, int len1, int len2, int len3, int len4) {
@@ -368,7 +369,7 @@ public class ArrayLong extends Array {
   }
 
   /** Concrete implementation of Array specialized for longs, rank 6. */
-  public static class D6 extends ArrayLong {
+  public static class D6 extends ArrayLong implements Serializable{
     private Index6D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,}. */
     public D6 (int len0, int len1, int len2, int len3, int len4, int len5) {
@@ -390,7 +391,7 @@ public class ArrayLong extends Array {
   }
 
   /** Concrete implementation of Array specialized for longs, rank 7. */
-  public static class D7 extends ArrayLong {
+  public static class D7 extends ArrayLong implements Serializable{
     private Index7D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,len6}. */
     public D7 (int len0, int len1, int len2, int len3, int len4, int len5, int len6) {
diff --git a/cdm/src/main/java/ucar/ma2/ArrayObject.java b/cdm/src/main/java/ucar/ma2/ArrayObject.java
index 37d9534..d5bf5e7 100644
--- a/cdm/src/main/java/ucar/ma2/ArrayObject.java
+++ b/cdm/src/main/java/ucar/ma2/ArrayObject.java
@@ -32,6 +32,8 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Concrete implementation of Array specialized for Objects.
  * Data storage is with 1D java array of Objects.
@@ -39,7 +41,7 @@ package ucar.ma2;
  * @see Array
  * @author caron
  */
-public class ArrayObject extends Array {
+public class ArrayObject extends Array implements Serializable{
 
   /** package private. use Array.factory() */
   static ArrayObject factory(Class classType, Index index) {
@@ -225,7 +227,7 @@ public class ArrayObject extends Array {
   public void setObject(int index, Object value) { storage[index] = value; }
 
   /** Concrete implementation of Array specialized for Objects, rank 0. */
-  public static class D0 extends ArrayObject {
+  public static class D0 extends ArrayObject implements Serializable{
     private Index0D ix;
     /** Constructor. */
     public D0 (Class classType) {
@@ -247,7 +249,7 @@ public class ArrayObject extends Array {
   }
 
   /** Concrete implementation of Array specialized for Objects, rank 1. */
-  public static class D1 extends ArrayObject {
+  public static class D1 extends ArrayObject implements Serializable{
     private Index1D ix;
     /** Constructor for array of shape {len0}. */
     public D1 (Class classType, int len0) {
@@ -269,7 +271,7 @@ public class ArrayObject extends Array {
   }
 
   /** Concrete implementation of Array specialized for Objects, rank 2. */
-  public static class D2 extends ArrayObject {
+  public static class D2 extends ArrayObject implements Serializable{
     private Index2D ix;
     /** Constructor for array of shape {len0,len1}. */
     public D2 (Class classType, int len0, int len1) {
@@ -291,7 +293,7 @@ public class ArrayObject extends Array {
   }
 
   /** Concrete implementation of Array specialized for Objects, rank 3. */
-  public static class D3 extends ArrayObject {
+  public static class D3 extends ArrayObject implements Serializable{
     private Index3D ix;
     /** Constructor for array of shape {len0,len1,len2}. */
     public D3 (Class classType, int len0, int len1, int len2) {
@@ -313,7 +315,7 @@ public class ArrayObject extends Array {
   }
 
   /** Concrete implementation of Array specialized for Objects, rank 4. */
-  public static class D4 extends ArrayObject {
+  public static class D4 extends ArrayObject implements Serializable{
     private Index4D ix;
     /** Constructor for array of shape {len0,len1,len2,len3}. */
     public D4 (Class classType, int len0, int len1, int len2, int len3) {
@@ -335,7 +337,7 @@ public class ArrayObject extends Array {
   }
 
   /** Concrete implementation of Array specialized for Objects, rank 5. */
-  public static class D5 extends ArrayObject {
+  public static class D5 extends ArrayObject implements Serializable{
     private Index5D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4}. */
     public D5 (Class classType, int len0, int len1, int len2, int len3, int len4) {
@@ -357,7 +359,7 @@ public class ArrayObject extends Array {
   }
 
   /** Concrete implementation of Array specialized for Objects, rank 6. */
-  public static class D6 extends ArrayObject {
+  public static class D6 extends ArrayObject implements Serializable{
     private Index6D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,}. */
     public D6 (Class classType, int len0, int len1, int len2, int len3, int len4, int len5) {
@@ -379,7 +381,7 @@ public class ArrayObject extends Array {
   }
 
   /** Concrete implementation of Array specialized for Objects, rank 7. */
-  public static class D7 extends ArrayObject {
+  public static class D7 extends ArrayObject implements Serializable{
     private Index7D ix;
     /** Constructor for array of shape {len0,len1,len2,len3,len4,len5,len6}. */
     public D7 (Class classType, int len0, int len1, int len2, int len3, int len4, int len5, int len6) {
diff --git a/cdm/src/main/java/ucar/ma2/Index.java b/cdm/src/main/java/ucar/ma2/Index.java
index 2482821..d698530 100644
--- a/cdm/src/main/java/ucar/ma2/Index.java
+++ b/cdm/src/main/java/ucar/ma2/Index.java
@@ -32,6 +32,7 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
 import java.util.List;
 
 /**
@@ -46,7 +47,7 @@ import java.util.List;
  * @see Array
  */
 
-public class  Index implements Cloneable {
+public class  Index implements Cloneable, Serializable{
   public static final Index0D scalarIndexImmutable = new Index0D(); // immutable, so can be shared
 
   /**
diff --git a/cdm/src/main/java/ucar/ma2/Index0D.java b/cdm/src/main/java/ucar/ma2/Index0D.java
index 4ee25cf..63939e4 100644
--- a/cdm/src/main/java/ucar/ma2/Index0D.java
+++ b/cdm/src/main/java/ucar/ma2/Index0D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 0 arrays, ie scalars.
  *
  * @see Index
  * @author caron
  */
-public class Index0D extends Index {
+public class Index0D extends Index implements Serializable{
 
   Index0D() {
     super(0);
diff --git a/cdm/src/main/java/ucar/ma2/Index1D.java b/cdm/src/main/java/ucar/ma2/Index1D.java
index 7341d05..607ad7e 100644
--- a/cdm/src/main/java/ucar/ma2/Index1D.java
+++ b/cdm/src/main/java/ucar/ma2/Index1D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 1 arrays.
  *
  * @see Index
  * @author caron
  */
-public class Index1D extends Index {
+public class Index1D extends Index implements Serializable{
 
   /** current element's indices */
   private int curr0;
diff --git a/cdm/src/main/java/ucar/ma2/Index2D.java b/cdm/src/main/java/ucar/ma2/Index2D.java
index e222f8f..d4256c9 100644
--- a/cdm/src/main/java/ucar/ma2/Index2D.java
+++ b/cdm/src/main/java/ucar/ma2/Index2D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 2 arrays.
  *
  * @see Index
  * @author caron
  */
-public class Index2D extends Index {
+public class Index2D extends Index implements Serializable{
 
   /** current element's indices */
   private int curr0, curr1;
diff --git a/cdm/src/main/java/ucar/ma2/Index3D.java b/cdm/src/main/java/ucar/ma2/Index3D.java
index 5743246..68e17f4 100644
--- a/cdm/src/main/java/ucar/ma2/Index3D.java
+++ b/cdm/src/main/java/ucar/ma2/Index3D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 3 arrays.
  *
  * @see Index
  * @author caron
  */
-public class Index3D extends Index {
+public class Index3D extends Index implements Serializable{
 
   /** current element's indices */
   private int curr0, curr1, curr2;
diff --git a/cdm/src/main/java/ucar/ma2/Index4D.java b/cdm/src/main/java/ucar/ma2/Index4D.java
index 02a433b..b5950c5 100644
--- a/cdm/src/main/java/ucar/ma2/Index4D.java
+++ b/cdm/src/main/java/ucar/ma2/Index4D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 4 arrays.
  *
  * @see Index
  * @author caron
  */
-public class Index4D extends Index {
+public class Index4D extends Index implements Serializable{
 
   /** current element's indices */
   private int curr0, curr1, curr2, curr3;
diff --git a/cdm/src/main/java/ucar/ma2/Index5D.java b/cdm/src/main/java/ucar/ma2/Index5D.java
index 264ef26..bb9d169 100644
--- a/cdm/src/main/java/ucar/ma2/Index5D.java
+++ b/cdm/src/main/java/ucar/ma2/Index5D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 5 arrays.
  *
  * @see Index
  * @author caron
  */
-public class Index5D extends Index {
+public class Index5D extends Index implements Serializable{
 
   /** current element's indices */
   private int curr0, curr1, curr2, curr3, curr4;
diff --git a/cdm/src/main/java/ucar/ma2/Index6D.java b/cdm/src/main/java/ucar/ma2/Index6D.java
index 090831c..0dc4341 100644
--- a/cdm/src/main/java/ucar/ma2/Index6D.java
+++ b/cdm/src/main/java/ucar/ma2/Index6D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 6 arrays.
  *
  * @see Index
  * @author caron
  */
-public class Index6D extends Index {
+public class Index6D extends Index implements Serializable{
 
   /** current element's indices */
   private int curr0, curr1, curr2, curr3, curr4, curr5;
diff --git a/cdm/src/main/java/ucar/ma2/Index7D.java b/cdm/src/main/java/ucar/ma2/Index7D.java
index 722264c..f8b2560 100644
--- a/cdm/src/main/java/ucar/ma2/Index7D.java
+++ b/cdm/src/main/java/ucar/ma2/Index7D.java
@@ -32,13 +32,15 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
+
 /**
  * Specialization of Index for rank 7 arrays.
  *
  * @see Index
  * @author caron
  */
-public class Index7D extends Index {
+public class Index7D extends Index implements Serializable{
 
   /** current element's indices */
   private int curr0, curr1, curr2, curr3, curr4, curr5, curr6;
diff --git a/cdm/src/main/java/ucar/ma2/IndexConstant.java b/cdm/src/main/java/ucar/ma2/IndexConstant.java
index 545d5be..8a2c45b 100644
--- a/cdm/src/main/java/ucar/ma2/IndexConstant.java
+++ b/cdm/src/main/java/ucar/ma2/IndexConstant.java
@@ -32,6 +32,7 @@
  */
 package ucar.ma2;
 
+import java.io.Serializable;
 import java.util.List;
 
 /**
@@ -41,7 +42,7 @@ import java.util.List;
  * @author caron
  */
  // LOOK : need to override section, etc !!
-public class IndexConstant extends Index {
+public class IndexConstant extends Index implements Serializable{
 
   protected IndexConstant(int rank) {
     super( rank);
diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
index 7f682af..88d1d06 100644
--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
+++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
@@ -585,7 +585,8 @@ public class N3header {
 
     throw new IllegalArgumentException("unknown DataType == " + dt);
   }
-
+  boolean largeFile;
+  Formatter fout;
   /**
    * Write the header out, based on ncfile structures.
    *
@@ -599,10 +600,16 @@ public class N3header {
   void create(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile, int extra, boolean largeFile, Formatter fout) throws IOException {
     this.raf = raf;
     this.ncfile = ncfile;
-
-    writeHeader(extra, largeFile, false, fout);
+    this.ncfile = ncfile;
+    this.largeFile=largeFile;
+    this.fout=fout;
+    //writeHeader(extra, largeFile, false, fout);
   }
-
+  
+  void writeHeader() throws IOException{ //called by writeAllVarsOnce in N3iosp.java
+	  writeHeader(0, largeFile, false, fout);
+  }
+  
   boolean rewriteHeader(boolean largeFile, Formatter fout) throws IOException {
     int want = sizeHeader(largeFile);
     if (want > dataStart)
@@ -623,8 +630,8 @@ public class N3header {
     raf.write(largeFile ? N3header.MAGIC_LONG : N3header.MAGIC);
 
     // numrecs
-    raf.writeInt(0);
-
+    //raf.writeInt(0);
+    raf.writeInt(numrecs);//write final numrecs;
     // dims
     List dims = ncfile.getDimensions();
     int numdims = dims.size();
diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
index be1f48e..1d1ad9f 100644
--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
+++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
@@ -655,8 +655,8 @@ public String NC_check_name(String name) {
 
     _create(raf);
 
-    if (fill)
-      fillNonRecordVariables();
+    //if (fill)
+      //fillNonRecordVariables();
     //else
     //  raf.setMinLength(recStart); // make sure file length is long enough, even if not written to.
   }
@@ -669,14 +669,20 @@ public String NC_check_name(String name) {
   // write
 
   public void writeData(Variable v2, Section section, Array values) throws java.io.IOException, InvalidRangeException {
-    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+	  if (arrMap == null)
+			arrMap = new HashMap<String, Array>();
+		if (secMap == null)
+			secMap = new HashMap<String, Section>();
+		arrMap.put(v2.getName(), values);
+		secMap.put(v2.getName(), section);
+	N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
     DataType dataType = v2.getDataType();
 
     if (v2.isUnlimited()) {
       Range firstRange = section.getRange(0);
       setNumrecs(firstRange.last() + 1);
     }
-
+/*
     if (v2 instanceof Structure) {
       writeRecordData((Structure) v2, section, values);
 
@@ -684,7 +690,7 @@ public String NC_check_name(String name) {
       Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
         new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
       writeData(values, layout, dataType);
-    }
+    }*/
   }
 
   private void writeRecordData(ucar.nc2.Structure s, Section section, Array values) throws java.io.IOException, ucar.ma2.InvalidRangeException {
@@ -745,10 +751,10 @@ public String NC_check_name(String name) {
     }
 
     // extend file, handle filling
-    if (fill)
-      fillRecordVariables(startRec, n);
-    else
-      raf.setMinLength( header.calcFileSize());
+    //if (fill)
+      //fillRecordVariables(startRec, n);
+    //else
+      //raf.setMinLength( header.calcFileSize());
   }
 
   /**
@@ -874,16 +880,24 @@ public String NC_check_name(String name) {
 
   public void flush() throws java.io.IOException {
     raf.flush();
-    header.writeNumrecs();
-    raf.flush();
+   //header.writeNumrecs();
+    //raf.flush();
   }
 
   public void close() throws java.io.IOException {
-    if (raf != null) {
-      long size = header.calcFileSize();
-      raf.setMinLength( size);
-      raf.close();
-    }
+	  if(raf.isWritingFile()){
+			try {
+				writeAllVarsOnce();
+			} catch (InvalidRangeException e) {
+				e.printStackTrace();
+			}
+		}
+	  if (raf != null) {
+      //long size = header.calcFileSize();
+      //raf.setMinLength( size);
+		  raf.close();
+	  }
+    
     raf = null;
   }
 
@@ -913,6 +927,174 @@ public String NC_check_name(String name) {
 
   public String getFileTypeDescription()  { return "NetCDF-3/CDM"; }
 
+  protected HashMap<String, Array> arrMap;
+	protected HashMap<String, Section> secMap;
+	protected int maxNumrecs = 0;
+	protected ArrayList<Variable> unlimVars;
+
+	protected ArrayList<Long> recs;
+
+	protected ArrayList<DataType> dtypes;
+
+	/**
+	 * Cache all variables in memory and write them to HDFS once.
+	 */
+	public void writeAllVarsOnce() throws IOException, InvalidRangeException {
+		
+		header.writeHeader(); //write header;
+		// flush();
+		if (secMap == null){
+			if(!fill){
+				throw new IOException(
+				"You should give all varibles values when fill is not set");
+			}
+			return;
+		}
+			
+		for (Variable v : ncfile.getVariables()) {
+			if (v instanceof Structure) {
+				writeRecordData((Structure) v, secMap.get(v.getName()), arrMap
+						.get(v.getName()));
+			} else {
+				if (!v.isUnlimited()) {
+					N3header.Vinfo vinfo = (N3header.Vinfo) v.getSPobject();
+					Layout layout = new LayoutRegular(vinfo.begin, v
+							.getElementSize(), v.getShape(), secMap.get(v
+							.getName()));
+
+					Array arr = arrMap.get(v.getName());
+
+					if (arr == null) {
+						// if varible value is not set , fill with the default
+						// values
+						Array a = makeConstantArray(v);
+						writeData(a, layout, v.getDataType());
+						/*System.out.print("file Value:" + v.getName()
+								+ "value :" + a.toString() + "\n");*/
+
+					} else {
+						// the value size is not equal with the varible size ,is
+						// not suportted currently
+						if (arr.getSize() != v.getSize())
+							throw new IOException("Value shape for "
+									+ v.getName()
+									+ "is not equals to the defination");
+						writeData(arr, layout, v.getDataType());
+					}
+
+				} else {
+					if (unlimVars == null) {
+						unlimVars = new ArrayList<Variable>();
+						dtypes = new ArrayList<DataType>();
+						recs = new ArrayList<Long>();
+					}
+					unlimVars.add(v);
+					dtypes.add(v.getDataType());
+					recs.add(v.getSize()
+							/ (v.getDimensions().get(0).getLength()));
+					// System.out.print("size
+					// :"+v.getSize()/(v.getDimensions().get(0).getLength())+"\n");
+				}
+			}
+		}
+		if (unlimVars == null)
+			return;
+		int len = unlimVars.size();
+		//System.out.print(header.numrecs + "\n");
+		for (int i = 0; i < header.numrecs; ++i) {
+			for (int j = 0; j < len; ++j) {
+				Variable v = unlimVars.get(j);
+				Array arr = arrMap.get(v.getName());
+				DataType dataType = dtypes.get(j);
+
+				// deal with different length record varibles
+				for (int m = 0; m < recs.get(j); ++m) {
+					if (arr.hasNext()) {
+						writeObject(arr, dataType);// write true data
+					} else {
+						writeObject(v, dataType);// write fill data
+					}
+
+				}
+
+			}
+		}
+	}
+
+	protected void writeObject(Array arr, DataType dataType) throws IOException {
+		if (dataType == DataType.BYTE || dataType == DataType.CHAR) {
+			raf.write(arr.nextByte());
+			return;
+		} else if (dataType == DataType.STRING) {
+			String val = (String) arr.next();
+			if (val != null)
+				raf.write(val.getBytes("UTF-8"));
+			return;
+		} else if (dataType == DataType.SHORT) {
+			raf.writeShort(arr.nextShort());
+			return;
+		} else if (dataType == DataType.INT) {
+			raf.writeInt(arr.nextInt());
+			return;
+		} else if (dataType == DataType.FLOAT) {
+			raf.writeFloat(arr.nextFloat());
+			return;
+		} else if (dataType == DataType.DOUBLE) {
+			raf.writeDouble(arr.nextDouble());
+			return;
+		}
+		throw new IllegalStateException("dataType= " + dataType);
+	}
+
+	/**
+	 * find and set the fill value
+	 */
+	protected void writeObject(Variable v, DataType dataType)
+			throws IOException {
+		Class classType = v.getDataType().getPrimitiveClassType();
+		Attribute att = v.findAttribute("_FillValue");
+
+		Object storage = null;
+		if (classType == double.class) {
+			double storageP;
+			storageP = (att == null) ? NC_FILL_DOUBLE : att.getNumericValue()
+					.doubleValue();
+			raf.writeDouble(storageP);
+
+		} else if (classType == float.class) {
+			float storageP;
+			storageP = (att == null) ? NC_FILL_FLOAT : att.getNumericValue()
+					.floatValue();
+			raf.writeFloat(storageP);
+
+		} else if (classType == int.class) {
+			int storageP;
+			storageP = (att == null) ? NC_FILL_INT : att.getNumericValue()
+					.intValue();
+			raf.writeInt(storageP);
+
+		} else if (classType == short.class) {
+			short storageP;
+			storageP = (att == null) ? NC_FILL_SHORT : att.getNumericValue()
+					.shortValue();
+			raf.writeShort(storageP);
+
+		} else if (classType == byte.class) {
+			byte storageP;
+			storageP = (att == null) ? NC_FILL_BYTE : att.getNumericValue()
+					.byteValue();
+			raf.writeByte(storageP);
+
+		} else if (classType == char.class) {
+			char storageP;
+			storageP = (att != null) && (att.getStringValue().length() > 0) ? att
+					.getStringValue().charAt(0)
+					: NC_FILL_CHAR;
+			raf.write(storageP);
+		}
+
+	}
+  
   ////////////////////////////////////////////////////////////////////////////////////////////////////
   // stuff we need the subclass to implement
 
diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
index 28431d0..ae60b49 100644
--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
+++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
@@ -110,7 +110,7 @@ public class N3raf extends N3iosp  {
       IndexIterator ii = values.getIndexIterator();
       while (index.hasNext()) {
         Layout.Chunk chunk = index.next();
-        raf.seek ( chunk.getSrcPos());
+        raf.seekForWrite ( chunk.getSrcPos());
         for (int k=0; k<chunk.getNelems(); k++)
           raf.write( ii.getByteNext());
       }
@@ -120,7 +120,7 @@ public class N3raf extends N3iosp  {
       IndexIterator ii = values.getIndexIterator();
       while (index.hasNext()) {
         Layout.Chunk chunk = index.next();
-        raf.seek ( chunk.getSrcPos());
+        raf.seekForWrite ( chunk.getSrcPos());
         for (int k=0; k<chunk.getNelems(); k++) {
           String val = (String) ii.getObjectNext();
           if (val != null) raf.write( val.getBytes(CDM.utf8Charset)); // LOOK ??
@@ -132,7 +132,7 @@ public class N3raf extends N3iosp  {
       IndexIterator ii = values.getIndexIterator();
       while (index.hasNext()) {
         Layout.Chunk chunk = index.next();
-        raf.seek ( chunk.getSrcPos());
+        raf.seekForWrite ( chunk.getSrcPos());
         for (int k=0; k<chunk.getNelems(); k++)
           raf.writeShort( ii.getShortNext());
       }
@@ -142,7 +142,7 @@ public class N3raf extends N3iosp  {
       IndexIterator ii = values.getIndexIterator();
       while (index.hasNext()) {
         Layout.Chunk chunk = index.next();
-        raf.seek ( chunk.getSrcPos());
+        raf.seekForWrite ( chunk.getSrcPos());
         for (int k=0; k<chunk.getNelems(); k++)
           raf.writeInt( ii.getIntNext());
       }
@@ -152,7 +152,7 @@ public class N3raf extends N3iosp  {
       IndexIterator ii = values.getIndexIterator();
       while (index.hasNext()) {
         Layout.Chunk chunk = index.next();
-        raf.seek ( chunk.getSrcPos());
+        raf.seekForWrite ( chunk.getSrcPos());
         for (int k=0; k<chunk.getNelems(); k++)
           raf.writeFloat( ii.getFloatNext());
       }
@@ -162,7 +162,7 @@ public class N3raf extends N3iosp  {
       IndexIterator ii = values.getIndexIterator();
       while (index.hasNext()) {
         Layout.Chunk chunk = index.next();
-        raf.seek ( chunk.getSrcPos());
+        raf.seekForWrite ( chunk.getSrcPos());
         for (int k=0; k<chunk.getNelems(); k++)
           raf.writeDouble( ii.getDoubleNext());
       }
diff --git a/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java b/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
index fb59804..55bb614 100644
--- a/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
+++ b/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
@@ -44,7 +44,12 @@ import java.util.concurrent.atomic.AtomicInteger;
 import java.util.concurrent.atomic.AtomicLong;
 import java.nio.channels.WritableByteChannel;
 
-
+import org.apache.hadoop.conf.Configuration;
+import org.apache.hadoop.fs.FSDataInputStream;
+import org.apache.hadoop.fs.FSDataOutputStream;
+import org.apache.hadoop.fs.FileStatus;
+import org.apache.hadoop.fs.FileSystem;
+import org.apache.hadoop.fs.Path;
 /**
  * A buffered drop-in replacement for java.io.RandomAccessFile.
  * Instances of this class realise substantial speed increases over
@@ -175,9 +180,21 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
    * The underlying java.io.RandomAccessFile.
    */
   protected java.io.RandomAccessFile file;
+  protected FSDataInputStream hdfsInFile;
+  protected FSDataOutputStream hdfsOutFile;
+  protected FileSystem fs;
   protected java.nio.channels.FileChannel fileChannel;
 
   /**
+   * test if the file is on hdfs for writing
+   */
+  public boolean isWritingFile(){
+	  if(hdfsOutFile==null)
+		  return false;
+	  else
+		  return true;
+  }
+  /**
    * The offset in bytes from the file start, of the next read or
    * write operation.
    */
@@ -274,8 +291,13 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
       allFiles.add(location);
     }
 
-    this.file = new java.io.RandomAccessFile(location, mode);
-    this.readonly = mode.equals("r");
+    Configuration conf = new Configuration();  
+	fs = FileSystem.get(java.net.URI.create(location), conf);
+	if(mode.toLowerCase().contains("w")){
+		this.hdfsOutFile=fs.create(new Path(location));
+    }
+    this.hdfsInFile = fs.open(new Path(location));
+    this.readonly = true;
     init(bufferSize);
 
     if (debugLeaks) {
@@ -293,7 +315,7 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
   public java.io.RandomAccessFile getRandomAccessFile() {
     return this.file;
   }
-
+  
   private void init(int bufferSize) {
     // Initialise the buffer
     bufferStart = 0;
@@ -339,12 +361,16 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
       if (showOpen) System.out.println("  close " + location);
     }
 
-    if (file == null)
-      return;
+    /*if (file == null)
+      return;*/
 
     // If we are writing and the buffer has been modified, flush the contents
     // of the buffer.
-    flush();
+    if(hdfsOutFile!=null){
+    	flush();
+    	hdfsOutFile.close();
+    }
+  
 
     /*
     if (!readonly && bufferModified) {
@@ -355,15 +381,21 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
     // may need to extend file, in case no fill is being used
     // may need to truncate file in case overwriting a longer file
     // use only if minLength is set (by N3iosp)
-    long fileSize = file.length();
+    //long fileSize = file.length();
+    long fileSize = fs.getFileStatus(new Path(location)).getLen();
     if (!readonly && (minLength != 0) && (minLength != fileSize)) {
       file.setLength(minLength);
       // System.out.println("TRUNCATE!!! minlength="+minLength);
     }
 
     // Close the underlying file object.
-    file.close();
-    file = null;  // help the gc
+    
+   
+    //file.close();
+    if(hdfsInFile!=null)
+    	hdfsInFile.close();
+    
+    //file = null;  // help the gc
   }
 
   /* @Override
@@ -410,7 +442,38 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
     // need new buffer, starting at pos
     readBuffer(pos);
   }
+  /**
+   * Set the position in the file for the HDFS write. It is used to maintain buffer variables. 
+   * All seek() in write should be replaced by seekForWrite();
+   * Compared to seek(),it does not read ahead to fill the buffer, but simply reset the buffer.
+   */
+  public void seekForWrite(long pos) throws IOException{
+	  //System.out.print("Seek to "+pos+"\n");
+	  if ((pos >= bufferStart) && (pos < dataEnd)) {
+	      filePosition = pos;
+	      return;
+	    }
+	    // need new buffer, starting at pos
+	    writeBuffer(pos);
+  }
+  /**
+   * flush the buffer, and simply reset it.
+   */
+  protected void writeBuffer(long pos) throws IOException {
+	    // If the current buffer is modified, write it to disk.
+	    if (bufferModified) {
+	      flush();
+	    }
 
+	    bufferStart = pos;
+	    filePosition = pos;
+	      dataSize = 0;
+	      endOfFile = true;
+
+	    // Cache the position of the buffer end.
+	    dataEnd = bufferStart + dataSize;
+	  }
+  
   protected void readBuffer(long pos) throws IOException {
     // If the current buffer is modified, write it to disk.
     if (bufferModified) {
@@ -461,7 +524,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
    * @throws IOException if an I/O error occurrs.
    */
   public long length() throws IOException {
-    long fileLength = file.length();
+    //long fileLength = file.length();
+    long fileLength = fs.getFileStatus(new Path(location)).getLen();
     if (fileLength < dataEnd) {
       return dataEnd;
     } else {
@@ -492,12 +556,15 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
    * @throws IOException if an I/O error occurs.
    */
   public void flush() throws IOException {
-    if (bufferModified) {
-      file.seek(bufferStart);
-      file.write(buffer, 0, dataSize);
-      //System.out.println("--flush at "+bufferStart+" dataSize= "+dataSize+ " filePosition= "+filePosition);
-      bufferModified = false;
-    }
+	 if(hdfsOutFile!=null){
+		 if (bufferModified) {
+			 //file.seek(bufferStart);
+			 //file.write(buffer, 0, dataSize);
+			 hdfsOutFile.write(buffer, 0, dataSize);
+			 //System.out.println("--flush at "+bufferStart+" dataSize= "+dataSize+ " filePosition= "+filePosition);
+			 bufferModified = false;
+		 }
+	}
 
     /* check min length
     if (!readonly && (minLength != 0) && (minLength != file.length())) {
@@ -660,8 +727,10 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
    * @throws IOException on io error
    */
   protected int read_(long pos, byte[] b, int offset, int len) throws IOException {
-    file.seek(pos);
-    int n = file.read(b, offset, len);
+    //file.seek(pos);
+    //int n = file.read(b, offset, len);
+	hdfsInFile.seek(pos);
+	int n= hdfsInFile.read(b, offset, len);
     if (debugAccess) {
       if (showRead)
         System.out.println(" **read_ " + location + " = " + len + " bytes at " + pos + "; block = " + (pos / buffer.length));
@@ -833,7 +902,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
 
         // ...or do another seek to get a new buffer, and start again...
       } else {
-        seek(filePosition);
+        //seek(filePosition);
+    	seekForWrite(filePosition);
         write(b);
       }
     }
@@ -874,7 +944,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
       // the new buffer.
       if (copyLength < len) {
         //System.out.println("--need more "+copyLength+" "+len+" space= "+spaceInBuffer);
-        seek(filePosition);   // triggers a flush
+        //seek(filePosition);   // triggers a flush
+        seekForWrite(filePosition);   // triggers a flush
         System.arraycopy(b, off + copyLength, buffer, (int) (filePosition - bufferStart), len - copyLength);
         bufferModified = true;
         long myDataEnd = filePosition + (len - copyLength);
@@ -890,8 +961,9 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
       if (bufferModified) {
         flush();
       }
-      file.seek(filePosition);  // moved per Steve Cerruti; Jan 14, 2005
-      file.write(b, off, len);
+      //file.seek(filePosition);  // moved per Steve Cerruti; Jan 14, 2005
+      //file.write(b, off, len);
+      hdfsOutFile.write(b,off,len);
       //System.out.println("--write at "+filePosition+" "+len);
 
       filePosition += len;
diff --git a/cdm/v4.3.16.patch b/cdm/v4.3.16.patch
new file mode 100644
index 0000000..96a3087
--- /dev/null
+++ b/cdm/v4.3.16.patch
@@ -0,0 +1,1237 @@
+diff --git a/cdm/pom.xml b/cdm/pom.xml
+index be0687d..f339650 100644
+--- a/cdm/pom.xml
++++ b/cdm/pom.xml
+@@ -105,7 +105,11 @@
+       <artifactId>slf4j-jdk14</artifactId>
+       <scope>test</scope>
+     </dependency>
+-
++    <dependency>
++        <groupId>org.apache.hadoop</groupId>
++        <artifactId>hadoop-core</artifactId>
++        <version>1.0.4</version>
++    </dependency>
+   </dependencies>
+ 
+ 
+diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
+index 7f682af..88d1d06 100644
+--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
++++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
+@@ -585,7 +585,8 @@ public class N3header {
+ 
+     throw new IllegalArgumentException("unknown DataType == " + dt);
+   }
+-
++  boolean largeFile;
++  Formatter fout;
+   /**
+    * Write the header out, based on ncfile structures.
+    *
+@@ -599,10 +600,16 @@ public class N3header {
+   void create(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile, int extra, boolean largeFile, Formatter fout) throws IOException {
+     this.raf = raf;
+     this.ncfile = ncfile;
+-
+-    writeHeader(extra, largeFile, false, fout);
++    this.ncfile = ncfile;
++    this.largeFile=largeFile;
++    this.fout=fout;
++    //writeHeader(extra, largeFile, false, fout);
+   }
+-
++  
++  void writeHeader() throws IOException{ //called by writeAllVarsOnce in N3iosp.java
++	  writeHeader(0, largeFile, false, fout);
++  }
++  
+   boolean rewriteHeader(boolean largeFile, Formatter fout) throws IOException {
+     int want = sizeHeader(largeFile);
+     if (want > dataStart)
+@@ -623,8 +630,8 @@ public class N3header {
+     raf.write(largeFile ? N3header.MAGIC_LONG : N3header.MAGIC);
+ 
+     // numrecs
+-    raf.writeInt(0);
+-
++    //raf.writeInt(0);
++    raf.writeInt(numrecs);//write final numrecs;
+     // dims
+     List dims = ncfile.getDimensions();
+     int numdims = dims.size();
+diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
+index be1f48e..1d1ad9f 100644
+--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
++++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
+@@ -655,8 +655,8 @@ public String NC_check_name(String name) {
+ 
+     _create(raf);
+ 
+-    if (fill)
+-      fillNonRecordVariables();
++    //if (fill)
++      //fillNonRecordVariables();
+     //else
+     //  raf.setMinLength(recStart); // make sure file length is long enough, even if not written to.
+   }
+@@ -669,14 +669,20 @@ public String NC_check_name(String name) {
+   // write
+ 
+   public void writeData(Variable v2, Section section, Array values) throws java.io.IOException, InvalidRangeException {
+-    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
++	  if (arrMap == null)
++			arrMap = new HashMap<String, Array>();
++		if (secMap == null)
++			secMap = new HashMap<String, Section>();
++		arrMap.put(v2.getName(), values);
++		secMap.put(v2.getName(), section);
++	N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+     DataType dataType = v2.getDataType();
+ 
+     if (v2.isUnlimited()) {
+       Range firstRange = section.getRange(0);
+       setNumrecs(firstRange.last() + 1);
+     }
+-
++/*
+     if (v2 instanceof Structure) {
+       writeRecordData((Structure) v2, section, values);
+ 
+@@ -684,7 +690,7 @@ public String NC_check_name(String name) {
+       Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
+         new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
+       writeData(values, layout, dataType);
+-    }
++    }*/
+   }
+ 
+   private void writeRecordData(ucar.nc2.Structure s, Section section, Array values) throws java.io.IOException, ucar.ma2.InvalidRangeException {
+@@ -745,10 +751,10 @@ public String NC_check_name(String name) {
+     }
+ 
+     // extend file, handle filling
+-    if (fill)
+-      fillRecordVariables(startRec, n);
+-    else
+-      raf.setMinLength( header.calcFileSize());
++    //if (fill)
++      //fillRecordVariables(startRec, n);
++    //else
++      //raf.setMinLength( header.calcFileSize());
+   }
+ 
+   /**
+@@ -874,16 +880,24 @@ public String NC_check_name(String name) {
+ 
+   public void flush() throws java.io.IOException {
+     raf.flush();
+-    header.writeNumrecs();
+-    raf.flush();
++   //header.writeNumrecs();
++    //raf.flush();
+   }
+ 
+   public void close() throws java.io.IOException {
+-    if (raf != null) {
+-      long size = header.calcFileSize();
+-      raf.setMinLength( size);
+-      raf.close();
+-    }
++	  if(raf.isWritingFile()){
++			try {
++				writeAllVarsOnce();
++			} catch (InvalidRangeException e) {
++				e.printStackTrace();
++			}
++		}
++	  if (raf != null) {
++      //long size = header.calcFileSize();
++      //raf.setMinLength( size);
++		  raf.close();
++	  }
++    
+     raf = null;
+   }
+ 
+@@ -913,6 +927,174 @@ public String NC_check_name(String name) {
+ 
+   public String getFileTypeDescription()  { return "NetCDF-3/CDM"; }
+ 
++  protected HashMap<String, Array> arrMap;
++	protected HashMap<String, Section> secMap;
++	protected int maxNumrecs = 0;
++	protected ArrayList<Variable> unlimVars;
++
++	protected ArrayList<Long> recs;
++
++	protected ArrayList<DataType> dtypes;
++
++	/**
++	 * Cache all variables in memory and write them to HDFS once.
++	 */
++	public void writeAllVarsOnce() throws IOException, InvalidRangeException {
++		
++		header.writeHeader(); //write header;
++		// flush();
++		if (secMap == null){
++			if(!fill){
++				throw new IOException(
++				"You should give all varibles values when fill is not set");
++			}
++			return;
++		}
++			
++		for (Variable v : ncfile.getVariables()) {
++			if (v instanceof Structure) {
++				writeRecordData((Structure) v, secMap.get(v.getName()), arrMap
++						.get(v.getName()));
++			} else {
++				if (!v.isUnlimited()) {
++					N3header.Vinfo vinfo = (N3header.Vinfo) v.getSPobject();
++					Layout layout = new LayoutRegular(vinfo.begin, v
++							.getElementSize(), v.getShape(), secMap.get(v
++							.getName()));
++
++					Array arr = arrMap.get(v.getName());
++
++					if (arr == null) {
++						// if varible value is not set , fill with the default
++						// values
++						Array a = makeConstantArray(v);
++						writeData(a, layout, v.getDataType());
++						/*System.out.print("file Value:" + v.getName()
++								+ "value :" + a.toString() + "\n");*/
++
++					} else {
++						// the value size is not equal with the varible size ,is
++						// not suportted currently
++						if (arr.getSize() != v.getSize())
++							throw new IOException("Value shape for "
++									+ v.getName()
++									+ "is not equals to the defination");
++						writeData(arr, layout, v.getDataType());
++					}
++
++				} else {
++					if (unlimVars == null) {
++						unlimVars = new ArrayList<Variable>();
++						dtypes = new ArrayList<DataType>();
++						recs = new ArrayList<Long>();
++					}
++					unlimVars.add(v);
++					dtypes.add(v.getDataType());
++					recs.add(v.getSize()
++							/ (v.getDimensions().get(0).getLength()));
++					// System.out.print("size
++					// :"+v.getSize()/(v.getDimensions().get(0).getLength())+"\n");
++				}
++			}
++		}
++		if (unlimVars == null)
++			return;
++		int len = unlimVars.size();
++		//System.out.print(header.numrecs + "\n");
++		for (int i = 0; i < header.numrecs; ++i) {
++			for (int j = 0; j < len; ++j) {
++				Variable v = unlimVars.get(j);
++				Array arr = arrMap.get(v.getName());
++				DataType dataType = dtypes.get(j);
++
++				// deal with different length record varibles
++				for (int m = 0; m < recs.get(j); ++m) {
++					if (arr.hasNext()) {
++						writeObject(arr, dataType);// write true data
++					} else {
++						writeObject(v, dataType);// write fill data
++					}
++
++				}
++
++			}
++		}
++	}
++
++	protected void writeObject(Array arr, DataType dataType) throws IOException {
++		if (dataType == DataType.BYTE || dataType == DataType.CHAR) {
++			raf.write(arr.nextByte());
++			return;
++		} else if (dataType == DataType.STRING) {
++			String val = (String) arr.next();
++			if (val != null)
++				raf.write(val.getBytes("UTF-8"));
++			return;
++		} else if (dataType == DataType.SHORT) {
++			raf.writeShort(arr.nextShort());
++			return;
++		} else if (dataType == DataType.INT) {
++			raf.writeInt(arr.nextInt());
++			return;
++		} else if (dataType == DataType.FLOAT) {
++			raf.writeFloat(arr.nextFloat());
++			return;
++		} else if (dataType == DataType.DOUBLE) {
++			raf.writeDouble(arr.nextDouble());
++			return;
++		}
++		throw new IllegalStateException("dataType= " + dataType);
++	}
++
++	/**
++	 * find and set the fill value
++	 */
++	protected void writeObject(Variable v, DataType dataType)
++			throws IOException {
++		Class classType = v.getDataType().getPrimitiveClassType();
++		Attribute att = v.findAttribute("_FillValue");
++
++		Object storage = null;
++		if (classType == double.class) {
++			double storageP;
++			storageP = (att == null) ? NC_FILL_DOUBLE : att.getNumericValue()
++					.doubleValue();
++			raf.writeDouble(storageP);
++
++		} else if (classType == float.class) {
++			float storageP;
++			storageP = (att == null) ? NC_FILL_FLOAT : att.getNumericValue()
++					.floatValue();
++			raf.writeFloat(storageP);
++
++		} else if (classType == int.class) {
++			int storageP;
++			storageP = (att == null) ? NC_FILL_INT : att.getNumericValue()
++					.intValue();
++			raf.writeInt(storageP);
++
++		} else if (classType == short.class) {
++			short storageP;
++			storageP = (att == null) ? NC_FILL_SHORT : att.getNumericValue()
++					.shortValue();
++			raf.writeShort(storageP);
++
++		} else if (classType == byte.class) {
++			byte storageP;
++			storageP = (att == null) ? NC_FILL_BYTE : att.getNumericValue()
++					.byteValue();
++			raf.writeByte(storageP);
++
++		} else if (classType == char.class) {
++			char storageP;
++			storageP = (att != null) && (att.getStringValue().length() > 0) ? att
++					.getStringValue().charAt(0)
++					: NC_FILL_CHAR;
++			raf.write(storageP);
++		}
++
++	}
++  
+   ////////////////////////////////////////////////////////////////////////////////////////////////////
+   // stuff we need the subclass to implement
+ 
+diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
+index 28431d0..ae60b49 100644
+--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
++++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
+@@ -110,7 +110,7 @@ public class N3raf extends N3iosp  {
+       IndexIterator ii = values.getIndexIterator();
+       while (index.hasNext()) {
+         Layout.Chunk chunk = index.next();
+-        raf.seek ( chunk.getSrcPos());
++        raf.seekForWrite ( chunk.getSrcPos());
+         for (int k=0; k<chunk.getNelems(); k++)
+           raf.write( ii.getByteNext());
+       }
+@@ -120,7 +120,7 @@ public class N3raf extends N3iosp  {
+       IndexIterator ii = values.getIndexIterator();
+       while (index.hasNext()) {
+         Layout.Chunk chunk = index.next();
+-        raf.seek ( chunk.getSrcPos());
++        raf.seekForWrite ( chunk.getSrcPos());
+         for (int k=0; k<chunk.getNelems(); k++) {
+           String val = (String) ii.getObjectNext();
+           if (val != null) raf.write( val.getBytes(CDM.utf8Charset)); // LOOK ??
+@@ -132,7 +132,7 @@ public class N3raf extends N3iosp  {
+       IndexIterator ii = values.getIndexIterator();
+       while (index.hasNext()) {
+         Layout.Chunk chunk = index.next();
+-        raf.seek ( chunk.getSrcPos());
++        raf.seekForWrite ( chunk.getSrcPos());
+         for (int k=0; k<chunk.getNelems(); k++)
+           raf.writeShort( ii.getShortNext());
+       }
+@@ -142,7 +142,7 @@ public class N3raf extends N3iosp  {
+       IndexIterator ii = values.getIndexIterator();
+       while (index.hasNext()) {
+         Layout.Chunk chunk = index.next();
+-        raf.seek ( chunk.getSrcPos());
++        raf.seekForWrite ( chunk.getSrcPos());
+         for (int k=0; k<chunk.getNelems(); k++)
+           raf.writeInt( ii.getIntNext());
+       }
+@@ -152,7 +152,7 @@ public class N3raf extends N3iosp  {
+       IndexIterator ii = values.getIndexIterator();
+       while (index.hasNext()) {
+         Layout.Chunk chunk = index.next();
+-        raf.seek ( chunk.getSrcPos());
++        raf.seekForWrite ( chunk.getSrcPos());
+         for (int k=0; k<chunk.getNelems(); k++)
+           raf.writeFloat( ii.getFloatNext());
+       }
+@@ -162,7 +162,7 @@ public class N3raf extends N3iosp  {
+       IndexIterator ii = values.getIndexIterator();
+       while (index.hasNext()) {
+         Layout.Chunk chunk = index.next();
+-        raf.seek ( chunk.getSrcPos());
++        raf.seekForWrite ( chunk.getSrcPos());
+         for (int k=0; k<chunk.getNelems(); k++)
+           raf.writeDouble( ii.getDoubleNext());
+       }
+diff --git a/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java b/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
+index fb59804..55bb614 100644
+--- a/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
++++ b/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
+@@ -44,7 +44,12 @@ import java.util.concurrent.atomic.AtomicInteger;
+ import java.util.concurrent.atomic.AtomicLong;
+ import java.nio.channels.WritableByteChannel;
+ 
+-
++import org.apache.hadoop.conf.Configuration;
++import org.apache.hadoop.fs.FSDataInputStream;
++import org.apache.hadoop.fs.FSDataOutputStream;
++import org.apache.hadoop.fs.FileStatus;
++import org.apache.hadoop.fs.FileSystem;
++import org.apache.hadoop.fs.Path;
+ /**
+  * A buffered drop-in replacement for java.io.RandomAccessFile.
+  * Instances of this class realise substantial speed increases over
+@@ -175,9 +180,21 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+    * The underlying java.io.RandomAccessFile.
+    */
+   protected java.io.RandomAccessFile file;
++  protected FSDataInputStream hdfsInFile;
++  protected FSDataOutputStream hdfsOutFile;
++  protected FileSystem fs;
+   protected java.nio.channels.FileChannel fileChannel;
+ 
+   /**
++   * test if the file is on hdfs for writing
++   */
++  public boolean isWritingFile(){
++	  if(hdfsOutFile==null)
++		  return false;
++	  else
++		  return true;
++  }
++  /**
+    * The offset in bytes from the file start, of the next read or
+    * write operation.
+    */
+@@ -274,8 +291,13 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+       allFiles.add(location);
+     }
+ 
+-    this.file = new java.io.RandomAccessFile(location, mode);
+-    this.readonly = mode.equals("r");
++    Configuration conf = new Configuration();  
++	fs = FileSystem.get(java.net.URI.create(location), conf);
++	if(mode.toLowerCase().contains("w")){
++		this.hdfsOutFile=fs.create(new Path(location));
++    }
++    this.hdfsInFile = fs.open(new Path(location));
++    this.readonly = true;
+     init(bufferSize);
+ 
+     if (debugLeaks) {
+@@ -293,7 +315,7 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+   public java.io.RandomAccessFile getRandomAccessFile() {
+     return this.file;
+   }
+-
++  
+   private void init(int bufferSize) {
+     // Initialise the buffer
+     bufferStart = 0;
+@@ -339,12 +361,16 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+       if (showOpen) System.out.println("  close " + location);
+     }
+ 
+-    if (file == null)
+-      return;
++    /*if (file == null)
++      return;*/
+ 
+     // If we are writing and the buffer has been modified, flush the contents
+     // of the buffer.
+-    flush();
++    if(hdfsOutFile!=null){
++    	flush();
++    	hdfsOutFile.close();
++    }
++  
+ 
+     /*
+     if (!readonly && bufferModified) {
+@@ -355,15 +381,21 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+     // may need to extend file, in case no fill is being used
+     // may need to truncate file in case overwriting a longer file
+     // use only if minLength is set (by N3iosp)
+-    long fileSize = file.length();
++    //long fileSize = file.length();
++    long fileSize = fs.getFileStatus(new Path(location)).getLen();
+     if (!readonly && (minLength != 0) && (minLength != fileSize)) {
+       file.setLength(minLength);
+       // System.out.println("TRUNCATE!!! minlength="+minLength);
+     }
+ 
+     // Close the underlying file object.
+-    file.close();
+-    file = null;  // help the gc
++    
++   
++    //file.close();
++    if(hdfsInFile!=null)
++    	hdfsInFile.close();
++    
++    //file = null;  // help the gc
+   }
+ 
+   /* @Override
+@@ -410,7 +442,38 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+     // need new buffer, starting at pos
+     readBuffer(pos);
+   }
++  /**
++   * Set the position in the file for the HDFS write. It is used to maintain buffer variables. 
++   * All seek() in write should be replaced by seekForWrite();
++   * Compared to seek(),it does not read ahead to fill the buffer, but simply reset the buffer.
++   */
++  public void seekForWrite(long pos) throws IOException{
++	  //System.out.print("Seek to "+pos+"\n");
++	  if ((pos >= bufferStart) && (pos < dataEnd)) {
++	      filePosition = pos;
++	      return;
++	    }
++	    // need new buffer, starting at pos
++	    writeBuffer(pos);
++  }
++  /**
++   * flush the buffer, and simply reset it.
++   */
++  protected void writeBuffer(long pos) throws IOException {
++	    // If the current buffer is modified, write it to disk.
++	    if (bufferModified) {
++	      flush();
++	    }
+ 
++	    bufferStart = pos;
++	    filePosition = pos;
++	      dataSize = 0;
++	      endOfFile = true;
++
++	    // Cache the position of the buffer end.
++	    dataEnd = bufferStart + dataSize;
++	  }
++  
+   protected void readBuffer(long pos) throws IOException {
+     // If the current buffer is modified, write it to disk.
+     if (bufferModified) {
+@@ -461,7 +524,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+    * @throws IOException if an I/O error occurrs.
+    */
+   public long length() throws IOException {
+-    long fileLength = file.length();
++    //long fileLength = file.length();
++    long fileLength = fs.getFileStatus(new Path(location)).getLen();
+     if (fileLength < dataEnd) {
+       return dataEnd;
+     } else {
+@@ -492,12 +556,15 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+    * @throws IOException if an I/O error occurs.
+    */
+   public void flush() throws IOException {
+-    if (bufferModified) {
+-      file.seek(bufferStart);
+-      file.write(buffer, 0, dataSize);
+-      //System.out.println("--flush at "+bufferStart+" dataSize= "+dataSize+ " filePosition= "+filePosition);
+-      bufferModified = false;
+-    }
++	 if(hdfsOutFile!=null){
++		 if (bufferModified) {
++			 //file.seek(bufferStart);
++			 //file.write(buffer, 0, dataSize);
++			 hdfsOutFile.write(buffer, 0, dataSize);
++			 //System.out.println("--flush at "+bufferStart+" dataSize= "+dataSize+ " filePosition= "+filePosition);
++			 bufferModified = false;
++		 }
++	}
+ 
+     /* check min length
+     if (!readonly && (minLength != 0) && (minLength != file.length())) {
+@@ -660,8 +727,10 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+    * @throws IOException on io error
+    */
+   protected int read_(long pos, byte[] b, int offset, int len) throws IOException {
+-    file.seek(pos);
+-    int n = file.read(b, offset, len);
++    //file.seek(pos);
++    //int n = file.read(b, offset, len);
++	hdfsInFile.seek(pos);
++	int n= hdfsInFile.read(b, offset, len);
+     if (debugAccess) {
+       if (showRead)
+         System.out.println(" **read_ " + location + " = " + len + " bytes at " + pos + "; block = " + (pos / buffer.length));
+@@ -833,7 +902,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+ 
+         // ...or do another seek to get a new buffer, and start again...
+       } else {
+-        seek(filePosition);
++        //seek(filePosition);
++    	seekForWrite(filePosition);
+         write(b);
+       }
+     }
+@@ -874,7 +944,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+       // the new buffer.
+       if (copyLength < len) {
+         //System.out.println("--need more "+copyLength+" "+len+" space= "+spaceInBuffer);
+-        seek(filePosition);   // triggers a flush
++        //seek(filePosition);   // triggers a flush
++        seekForWrite(filePosition);   // triggers a flush
+         System.arraycopy(b, off + copyLength, buffer, (int) (filePosition - bufferStart), len - copyLength);
+         bufferModified = true;
+         long myDataEnd = filePosition + (len - copyLength);
+@@ -890,8 +961,9 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
+       if (bufferModified) {
+         flush();
+       }
+-      file.seek(filePosition);  // moved per Steve Cerruti; Jan 14, 2005
+-      file.write(b, off, len);
++      //file.seek(filePosition);  // moved per Steve Cerruti; Jan 14, 2005
++      //file.write(b, off, len);
++      hdfsOutFile.write(b,off,len);
+       //System.out.println("--write at "+filePosition+" "+len);
+ 
+       filePosition += len;
+diff --git a/cdm/v4.3.16.patch b/cdm/v4.3.16.patch
+new file mode 100644
+index 0000000..fe1b672
+--- /dev/null
++++ b/cdm/v4.3.16.patch
+@@ -0,0 +1,616 @@
++diff --git a/cdm/pom.xml b/cdm/pom.xml
++index be0687d..f339650 100644
++--- a/cdm/pom.xml
+++++ b/cdm/pom.xml
++@@ -105,7 +105,11 @@
++       <artifactId>slf4j-jdk14</artifactId>
++       <scope>test</scope>
++     </dependency>
++-
+++    <dependency>
+++        <groupId>org.apache.hadoop</groupId>
+++        <artifactId>hadoop-core</artifactId>
+++        <version>1.0.4</version>
+++    </dependency>
++   </dependencies>
++ 
++ 
++diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
++index 7f682af..88d1d06 100644
++--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
+++++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3header.java
++@@ -585,7 +585,8 @@ public class N3header {
++ 
++     throw new IllegalArgumentException("unknown DataType == " + dt);
++   }
++-
+++  boolean largeFile;
+++  Formatter fout;
++   /**
++    * Write the header out, based on ncfile structures.
++    *
++@@ -599,10 +600,16 @@ public class N3header {
++   void create(ucar.unidata.io.RandomAccessFile raf, ucar.nc2.NetcdfFile ncfile, int extra, boolean largeFile, Formatter fout) throws IOException {
++     this.raf = raf;
++     this.ncfile = ncfile;
++-
++-    writeHeader(extra, largeFile, false, fout);
+++    this.ncfile = ncfile;
+++    this.largeFile=largeFile;
+++    this.fout=fout;
+++    //writeHeader(extra, largeFile, false, fout);
++   }
++-
+++  
+++  void writeHeader() throws IOException{ //called by writeAllVarsOnce in N3iosp.java
+++	  writeHeader(0, largeFile, false, fout);
+++  }
+++  
++   boolean rewriteHeader(boolean largeFile, Formatter fout) throws IOException {
++     int want = sizeHeader(largeFile);
++     if (want > dataStart)
++@@ -623,8 +630,8 @@ public class N3header {
++     raf.write(largeFile ? N3header.MAGIC_LONG : N3header.MAGIC);
++ 
++     // numrecs
++-    raf.writeInt(0);
++-
+++    //raf.writeInt(0);
+++    raf.writeInt(numrecs);//write final numrecs;
++     // dims
++     List dims = ncfile.getDimensions();
++     int numdims = dims.size();
++diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
++index be1f48e..1d1ad9f 100644
++--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
+++++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3iosp.java
++@@ -655,8 +655,8 @@ public String NC_check_name(String name) {
++ 
++     _create(raf);
++ 
++-    if (fill)
++-      fillNonRecordVariables();
+++    //if (fill)
+++      //fillNonRecordVariables();
++     //else
++     //  raf.setMinLength(recStart); // make sure file length is long enough, even if not written to.
++   }
++@@ -669,14 +669,20 @@ public String NC_check_name(String name) {
++   // write
++ 
++   public void writeData(Variable v2, Section section, Array values) throws java.io.IOException, InvalidRangeException {
++-    N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
+++	  if (arrMap == null)
+++			arrMap = new HashMap<String, Array>();
+++		if (secMap == null)
+++			secMap = new HashMap<String, Section>();
+++		arrMap.put(v2.getName(), values);
+++		secMap.put(v2.getName(), section);
+++	N3header.Vinfo vinfo = (N3header.Vinfo) v2.getSPobject();
++     DataType dataType = v2.getDataType();
++ 
++     if (v2.isUnlimited()) {
++       Range firstRange = section.getRange(0);
++       setNumrecs(firstRange.last() + 1);
++     }
++-
+++/*
++     if (v2 instanceof Structure) {
++       writeRecordData((Structure) v2, section, values);
++ 
++@@ -684,7 +690,7 @@ public String NC_check_name(String name) {
++       Layout layout = (!v2.isUnlimited()) ? new LayoutRegular(vinfo.begin, v2.getElementSize(), v2.getShape(), section) :
++         new LayoutRegularSegmented(vinfo.begin, v2.getElementSize(), header.recsize, v2.getShape(), section);
++       writeData(values, layout, dataType);
++-    }
+++    }*/
++   }
++ 
++   private void writeRecordData(ucar.nc2.Structure s, Section section, Array values) throws java.io.IOException, ucar.ma2.InvalidRangeException {
++@@ -745,10 +751,10 @@ public String NC_check_name(String name) {
++     }
++ 
++     // extend file, handle filling
++-    if (fill)
++-      fillRecordVariables(startRec, n);
++-    else
++-      raf.setMinLength( header.calcFileSize());
+++    //if (fill)
+++      //fillRecordVariables(startRec, n);
+++    //else
+++      //raf.setMinLength( header.calcFileSize());
++   }
++ 
++   /**
++@@ -874,16 +880,24 @@ public String NC_check_name(String name) {
++ 
++   public void flush() throws java.io.IOException {
++     raf.flush();
++-    header.writeNumrecs();
++-    raf.flush();
+++   //header.writeNumrecs();
+++    //raf.flush();
++   }
++ 
++   public void close() throws java.io.IOException {
++-    if (raf != null) {
++-      long size = header.calcFileSize();
++-      raf.setMinLength( size);
++-      raf.close();
++-    }
+++	  if(raf.isWritingFile()){
+++			try {
+++				writeAllVarsOnce();
+++			} catch (InvalidRangeException e) {
+++				e.printStackTrace();
+++			}
+++		}
+++	  if (raf != null) {
+++      //long size = header.calcFileSize();
+++      //raf.setMinLength( size);
+++		  raf.close();
+++	  }
+++    
++     raf = null;
++   }
++ 
++@@ -913,6 +927,174 @@ public String NC_check_name(String name) {
++ 
++   public String getFileTypeDescription()  { return "NetCDF-3/CDM"; }
++ 
+++  protected HashMap<String, Array> arrMap;
+++	protected HashMap<String, Section> secMap;
+++	protected int maxNumrecs = 0;
+++	protected ArrayList<Variable> unlimVars;
+++
+++	protected ArrayList<Long> recs;
+++
+++	protected ArrayList<DataType> dtypes;
+++
+++	/**
+++	 * Cache all variables in memory and write them to HDFS once.
+++	 */
+++	public void writeAllVarsOnce() throws IOException, InvalidRangeException {
+++		
+++		header.writeHeader(); //write header;
+++		// flush();
+++		if (secMap == null){
+++			if(!fill){
+++				throw new IOException(
+++				"You should give all varibles values when fill is not set");
+++			}
+++			return;
+++		}
+++			
+++		for (Variable v : ncfile.getVariables()) {
+++			if (v instanceof Structure) {
+++				writeRecordData((Structure) v, secMap.get(v.getName()), arrMap
+++						.get(v.getName()));
+++			} else {
+++				if (!v.isUnlimited()) {
+++					N3header.Vinfo vinfo = (N3header.Vinfo) v.getSPobject();
+++					Layout layout = new LayoutRegular(vinfo.begin, v
+++							.getElementSize(), v.getShape(), secMap.get(v
+++							.getName()));
+++
+++					Array arr = arrMap.get(v.getName());
+++
+++					if (arr == null) {
+++						// if varible value is not set , fill with the default
+++						// values
+++						Array a = makeConstantArray(v);
+++						writeData(a, layout, v.getDataType());
+++						/*System.out.print("file Value:" + v.getName()
+++								+ "value :" + a.toString() + "\n");*/
+++
+++					} else {
+++						// the value size is not equal with the varible size ,is
+++						// not suportted currently
+++						if (arr.getSize() != v.getSize())
+++							throw new IOException("Value shape for "
+++									+ v.getName()
+++									+ "is not equals to the defination");
+++						writeData(arr, layout, v.getDataType());
+++					}
+++
+++				} else {
+++					if (unlimVars == null) {
+++						unlimVars = new ArrayList<Variable>();
+++						dtypes = new ArrayList<DataType>();
+++						recs = new ArrayList<Long>();
+++					}
+++					unlimVars.add(v);
+++					dtypes.add(v.getDataType());
+++					recs.add(v.getSize()
+++							/ (v.getDimensions().get(0).getLength()));
+++					// System.out.print("size
+++					// :"+v.getSize()/(v.getDimensions().get(0).getLength())+"\n");
+++				}
+++			}
+++		}
+++		if (unlimVars == null)
+++			return;
+++		int len = unlimVars.size();
+++		//System.out.print(header.numrecs + "\n");
+++		for (int i = 0; i < header.numrecs; ++i) {
+++			for (int j = 0; j < len; ++j) {
+++				Variable v = unlimVars.get(j);
+++				Array arr = arrMap.get(v.getName());
+++				DataType dataType = dtypes.get(j);
+++
+++				// deal with different length record varibles
+++				for (int m = 0; m < recs.get(j); ++m) {
+++					if (arr.hasNext()) {
+++						writeObject(arr, dataType);// write true data
+++					} else {
+++						writeObject(v, dataType);// write fill data
+++					}
+++
+++				}
+++
+++			}
+++		}
+++	}
+++
+++	protected void writeObject(Array arr, DataType dataType) throws IOException {
+++		if (dataType == DataType.BYTE || dataType == DataType.CHAR) {
+++			raf.write(arr.nextByte());
+++			return;
+++		} else if (dataType == DataType.STRING) {
+++			String val = (String) arr.next();
+++			if (val != null)
+++				raf.write(val.getBytes("UTF-8"));
+++			return;
+++		} else if (dataType == DataType.SHORT) {
+++			raf.writeShort(arr.nextShort());
+++			return;
+++		} else if (dataType == DataType.INT) {
+++			raf.writeInt(arr.nextInt());
+++			return;
+++		} else if (dataType == DataType.FLOAT) {
+++			raf.writeFloat(arr.nextFloat());
+++			return;
+++		} else if (dataType == DataType.DOUBLE) {
+++			raf.writeDouble(arr.nextDouble());
+++			return;
+++		}
+++		throw new IllegalStateException("dataType= " + dataType);
+++	}
+++
+++	/**
+++	 * find and set the fill value
+++	 */
+++	protected void writeObject(Variable v, DataType dataType)
+++			throws IOException {
+++		Class classType = v.getDataType().getPrimitiveClassType();
+++		Attribute att = v.findAttribute("_FillValue");
+++
+++		Object storage = null;
+++		if (classType == double.class) {
+++			double storageP;
+++			storageP = (att == null) ? NC_FILL_DOUBLE : att.getNumericValue()
+++					.doubleValue();
+++			raf.writeDouble(storageP);
+++
+++		} else if (classType == float.class) {
+++			float storageP;
+++			storageP = (att == null) ? NC_FILL_FLOAT : att.getNumericValue()
+++					.floatValue();
+++			raf.writeFloat(storageP);
+++
+++		} else if (classType == int.class) {
+++			int storageP;
+++			storageP = (att == null) ? NC_FILL_INT : att.getNumericValue()
+++					.intValue();
+++			raf.writeInt(storageP);
+++
+++		} else if (classType == short.class) {
+++			short storageP;
+++			storageP = (att == null) ? NC_FILL_SHORT : att.getNumericValue()
+++					.shortValue();
+++			raf.writeShort(storageP);
+++
+++		} else if (classType == byte.class) {
+++			byte storageP;
+++			storageP = (att == null) ? NC_FILL_BYTE : att.getNumericValue()
+++					.byteValue();
+++			raf.writeByte(storageP);
+++
+++		} else if (classType == char.class) {
+++			char storageP;
+++			storageP = (att != null) && (att.getStringValue().length() > 0) ? att
+++					.getStringValue().charAt(0)
+++					: NC_FILL_CHAR;
+++			raf.write(storageP);
+++		}
+++
+++	}
+++  
++   ////////////////////////////////////////////////////////////////////////////////////////////////////
++   // stuff we need the subclass to implement
++ 
++diff --git a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
++index 28431d0..ae60b49 100644
++--- a/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
+++++ b/cdm/src/main/java/ucar/nc2/iosp/netcdf3/N3raf.java
++@@ -110,7 +110,7 @@ public class N3raf extends N3iosp  {
++       IndexIterator ii = values.getIndexIterator();
++       while (index.hasNext()) {
++         Layout.Chunk chunk = index.next();
++-        raf.seek ( chunk.getSrcPos());
+++        raf.seekForWrite ( chunk.getSrcPos());
++         for (int k=0; k<chunk.getNelems(); k++)
++           raf.write( ii.getByteNext());
++       }
++@@ -120,7 +120,7 @@ public class N3raf extends N3iosp  {
++       IndexIterator ii = values.getIndexIterator();
++       while (index.hasNext()) {
++         Layout.Chunk chunk = index.next();
++-        raf.seek ( chunk.getSrcPos());
+++        raf.seekForWrite ( chunk.getSrcPos());
++         for (int k=0; k<chunk.getNelems(); k++) {
++           String val = (String) ii.getObjectNext();
++           if (val != null) raf.write( val.getBytes(CDM.utf8Charset)); // LOOK ??
++@@ -132,7 +132,7 @@ public class N3raf extends N3iosp  {
++       IndexIterator ii = values.getIndexIterator();
++       while (index.hasNext()) {
++         Layout.Chunk chunk = index.next();
++-        raf.seek ( chunk.getSrcPos());
+++        raf.seekForWrite ( chunk.getSrcPos());
++         for (int k=0; k<chunk.getNelems(); k++)
++           raf.writeShort( ii.getShortNext());
++       }
++@@ -142,7 +142,7 @@ public class N3raf extends N3iosp  {
++       IndexIterator ii = values.getIndexIterator();
++       while (index.hasNext()) {
++         Layout.Chunk chunk = index.next();
++-        raf.seek ( chunk.getSrcPos());
+++        raf.seekForWrite ( chunk.getSrcPos());
++         for (int k=0; k<chunk.getNelems(); k++)
++           raf.writeInt( ii.getIntNext());
++       }
++@@ -152,7 +152,7 @@ public class N3raf extends N3iosp  {
++       IndexIterator ii = values.getIndexIterator();
++       while (index.hasNext()) {
++         Layout.Chunk chunk = index.next();
++-        raf.seek ( chunk.getSrcPos());
+++        raf.seekForWrite ( chunk.getSrcPos());
++         for (int k=0; k<chunk.getNelems(); k++)
++           raf.writeFloat( ii.getFloatNext());
++       }
++@@ -162,7 +162,7 @@ public class N3raf extends N3iosp  {
++       IndexIterator ii = values.getIndexIterator();
++       while (index.hasNext()) {
++         Layout.Chunk chunk = index.next();
++-        raf.seek ( chunk.getSrcPos());
+++        raf.seekForWrite ( chunk.getSrcPos());
++         for (int k=0; k<chunk.getNelems(); k++)
++           raf.writeDouble( ii.getDoubleNext());
++       }
++diff --git a/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java b/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
++index fb59804..fbe160f 100644
++--- a/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
+++++ b/cdm/src/main/java/ucar/unidata/io/RandomAccessFile.java
++@@ -44,7 +44,12 @@ import java.util.concurrent.atomic.AtomicInteger;
++ import java.util.concurrent.atomic.AtomicLong;
++ import java.nio.channels.WritableByteChannel;
++ 
++-
+++import org.apache.hadoop.conf.Configuration;
+++import org.apache.hadoop.fs.FSDataInputStream;
+++import org.apache.hadoop.fs.FSDataOutputStream;
+++import org.apache.hadoop.fs.FileStatus;
+++import org.apache.hadoop.fs.FileSystem;
+++import org.apache.hadoop.fs.Path;
++ /**
++  * A buffered drop-in replacement for java.io.RandomAccessFile.
++  * Instances of this class realise substantial speed increases over
++@@ -175,9 +180,21 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++    * The underlying java.io.RandomAccessFile.
++    */
++   protected java.io.RandomAccessFile file;
+++  protected FSDataInputStream hdfsInFile;
+++  protected FSDataOutputStream hdfsOutFile;
+++  protected FileSystem fs;
++   protected java.nio.channels.FileChannel fileChannel;
++ 
++   /**
+++   * test if the file is on hdfs for writing
+++   */
+++  public boolean isWritingFile(){
+++	  if(hdfsOutFile==null)
+++		  return false;
+++	  else
+++		  return true;
+++  }
+++  /**
++    * The offset in bytes from the file start, of the next read or
++    * write operation.
++    */
++@@ -274,8 +291,13 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++       allFiles.add(location);
++     }
++ 
++-    this.file = new java.io.RandomAccessFile(location, mode);
++-    this.readonly = mode.equals("r");
+++    Configuration conf = new Configuration();  
+++	fs = FileSystem.get(java.net.URI.create(location), conf);
+++	if(mode.toLowerCase().contains("w")){
+++		this.hdfsOutFile=fs.create(new Path(location));
+++    }
+++    this.hdfsInFile = fs.open(new Path(location));
+++    this.readonly = true;
++     init(bufferSize);
++ 
++     if (debugLeaks) {
++@@ -293,7 +315,7 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++   public java.io.RandomAccessFile getRandomAccessFile() {
++     return this.file;
++   }
++-
+++  
++   private void init(int bufferSize) {
++     // Initialise the buffer
++     bufferStart = 0;
++@@ -339,12 +361,16 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++       if (showOpen) System.out.println("  close " + location);
++     }
++ 
++-    if (file == null)
++-      return;
+++    /*if (file == null)
+++      return;*/
++ 
++     // If we are writing and the buffer has been modified, flush the contents
++     // of the buffer.
++-    flush();
+++    if(hdfsOutFile!=null){
+++    	flush();
+++    	hdfsOutFile.close();
+++    }
+++  
++ 
++     /*
++     if (!readonly && bufferModified) {
++@@ -355,15 +381,22 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++     // may need to extend file, in case no fill is being used
++     // may need to truncate file in case overwriting a longer file
++     // use only if minLength is set (by N3iosp)
++-    long fileSize = file.length();
+++    //long fileSize = file.length();
+++    long fileSize = fs.getFileStatus(new Path(location)).getLen();
++     if (!readonly && (minLength != 0) && (minLength != fileSize)) {
++       file.setLength(minLength);
++       // System.out.println("TRUNCATE!!! minlength="+minLength);
++     }
++ 
++     // Close the underlying file object.
++-    file.close();
++-    file = null;  // help the gc
+++    
+++   
+++    //file.close();
+++    if(hdfsInFile!=null)
+++    	hdfsInFile.close();
+++    
+++    fs.close();
+++    //file = null;  // help the gc
++   }
++ 
++   /* @Override
++@@ -410,7 +443,38 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++     // need new buffer, starting at pos
++     readBuffer(pos);
++   }
+++  /**
+++   * Set the position in the file for the HDFS write. It is used to maintain buffer variables. 
+++   * All seek() in write should be replaced by seekForWrite();
+++   * Compared to seek(),it does not read ahead to fill the buffer, but simply reset the buffer.
+++   */
+++  public void seekForWrite(long pos) throws IOException{
+++	  //System.out.print("Seek to "+pos+"\n");
+++	  if ((pos >= bufferStart) && (pos < dataEnd)) {
+++	      filePosition = pos;
+++	      return;
+++	    }
+++	    // need new buffer, starting at pos
+++	    writeBuffer(pos);
+++  }
+++  /**
+++   * flush the buffer, and simply reset it.
+++   */
+++  protected void writeBuffer(long pos) throws IOException {
+++	    // If the current buffer is modified, write it to disk.
+++	    if (bufferModified) {
+++	      flush();
+++	    }
++ 
+++	    bufferStart = pos;
+++	    filePosition = pos;
+++	      dataSize = 0;
+++	      endOfFile = true;
+++
+++	    // Cache the position of the buffer end.
+++	    dataEnd = bufferStart + dataSize;
+++	  }
+++  
++   protected void readBuffer(long pos) throws IOException {
++     // If the current buffer is modified, write it to disk.
++     if (bufferModified) {
++@@ -461,7 +525,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++    * @throws IOException if an I/O error occurrs.
++    */
++   public long length() throws IOException {
++-    long fileLength = file.length();
+++    //long fileLength = file.length();
+++    long fileLength = fs.getFileStatus(new Path(location)).getLen();
++     if (fileLength < dataEnd) {
++       return dataEnd;
++     } else {
++@@ -492,12 +557,15 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++    * @throws IOException if an I/O error occurs.
++    */
++   public void flush() throws IOException {
++-    if (bufferModified) {
++-      file.seek(bufferStart);
++-      file.write(buffer, 0, dataSize);
++-      //System.out.println("--flush at "+bufferStart+" dataSize= "+dataSize+ " filePosition= "+filePosition);
++-      bufferModified = false;
++-    }
+++	 if(hdfsOutFile!=null){
+++		 if (bufferModified) {
+++			 //file.seek(bufferStart);
+++			 //file.write(buffer, 0, dataSize);
+++			 hdfsOutFile.write(buffer, 0, dataSize);
+++			 //System.out.println("--flush at "+bufferStart+" dataSize= "+dataSize+ " filePosition= "+filePosition);
+++			 bufferModified = false;
+++		 }
+++	}
++ 
++     /* check min length
++     if (!readonly && (minLength != 0) && (minLength != file.length())) {
++@@ -660,8 +728,10 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++    * @throws IOException on io error
++    */
++   protected int read_(long pos, byte[] b, int offset, int len) throws IOException {
++-    file.seek(pos);
++-    int n = file.read(b, offset, len);
+++    //file.seek(pos);
+++    //int n = file.read(b, offset, len);
+++	hdfsInFile.seek(pos);
+++	int n= hdfsInFile.read(b, offset, len);
++     if (debugAccess) {
++       if (showRead)
++         System.out.println(" **read_ " + location + " = " + len + " bytes at " + pos + "; block = " + (pos / buffer.length));
++@@ -833,7 +903,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++ 
++         // ...or do another seek to get a new buffer, and start again...
++       } else {
++-        seek(filePosition);
+++        //seek(filePosition);
+++    	seekForWrite(filePosition);
++         write(b);
++       }
++     }
++@@ -874,7 +945,8 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++       // the new buffer.
++       if (copyLength < len) {
++         //System.out.println("--need more "+copyLength+" "+len+" space= "+spaceInBuffer);
++-        seek(filePosition);   // triggers a flush
+++        //seek(filePosition);   // triggers a flush
+++        seekForWrite(filePosition);   // triggers a flush
++         System.arraycopy(b, off + copyLength, buffer, (int) (filePosition - bufferStart), len - copyLength);
++         bufferModified = true;
++         long myDataEnd = filePosition + (len - copyLength);
++@@ -890,8 +962,9 @@ public class RandomAccessFile implements DataInput, DataOutput, FileCacheable {
++       if (bufferModified) {
++         flush();
++       }
++-      file.seek(filePosition);  // moved per Steve Cerruti; Jan 14, 2005
++-      file.write(b, off, len);
+++      //file.seek(filePosition);  // moved per Steve Cerruti; Jan 14, 2005
+++      //file.write(b, off, len);
+++      hdfsOutFile.write(b,off,len);
++       //System.out.println("--write at "+filePosition+" "+len);
++ 
++       filePosition += len;
